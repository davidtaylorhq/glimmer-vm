import type { TupleIndices, VmMachineOp, VmOp, VmOpMap, VmOpName } from '@glimmer/interfaces';

export const OpNames: VmOpMap = [
  'PushFrame',
  'PopFrame',
  'InvokeVirtual',
  'InvokeStatic',
  'Jump',
  'Return',
  'ReturnTo',
  'PushTryFrame',
  'PopTryFrame',
  'UnwindTypeFrame',
  null,
  null,
  null,
  null,
  null,
  null,
  'Helper',
  'SetNamedVariables',
  'SetBlocks',
  'SetVariable',
  'SetBlock',
  'GetVariable',
  'GetProperty',
  'GetBlock',
  'SpreadBlock',
  'HasBlock',
  'HasBlockParams',
  'Concat',
  'Constant',
  'ConstantReference',
  'Primitive',
  'PrimitiveReference',
  'ReifyU32',
  'Dup',
  'Pop',
  'Load',
  'Fetch',
  'RootScope',
  'VirtualRootScope',
  'ChildScope',
  'PopScope',
  'Text',
  'Comment',
  'AppendHTML',
  'AppendSafeHTML',
  'AppendDocumentFragment',
  'AppendNode',
  'AppendText',
  'OpenElement',
  'OpenDynamicElement',
  'PushRemoteElement',
  'StaticAttr',
  'DynamicAttr',
  'ComponentAttr',
  'FlushElement',
  'CloseElement',
  'PopRemoteElement',
  'Modifier',
  'BindDynamicScope',
  'PushDynamicScope',
  'PopDynamicScope',
  'CompileBlock',
  'PushBlockScope',
  'PushSymbolTable',
  'InvokeYield',
  'JumpIf',
  'JumpUnless',
  'JumpEq',
  'AssertSame',
  'Enter',
  'Exit',
  'ToBoolean',
  'EnterList',
  'ExitList',
  'Iterate',
  'Main',
  'ContentType',
  'Curry',
  'PushComponentDefinition',
  'PushDynamicComponentInstance',
  'ResolveDynamicComponent',
  'ResolveCurriedComponent',
  'PushArgs',
  'PushEmptyArgs',
  'PrepareArgs',
  'CaptureArgs',
  'CreateComponent',
  'RegisterComponentDestructor',
  'PutComponentOperations',
  'GetComponentSelf',
  'GetComponentTagName',
  'GetComponentLayout',
  'SetupForEval',
  'PopulateLayout',
  'InvokeComponentLayout',
  'BeginComponentTransaction',
  'CommitComponentTransaction',
  'DidCreateElement',
  'DidRenderLayout',
  'Debugger',
  'StaticComponentAttr',
  'DynamicContentType',
  'DynamicHelper',
  'DynamicModifier',
  'IfInline',
  'Not',
  'GetDynamicVar',
  'Log',
  'PushUnwindTarget',
] as const;
export const OpSize = OpNames.length;

type OpMapKey<P> = P extends TupleIndices<VmOpMap> ? NonNullable<VmOpMap[P]> : never;

export const Op = OpNames.reduce(
  (acc, name, i) => {
    if (name !== null) acc[name] = i;
    return acc;
  },
  {} as Record<string, number>
) as { [P in TupleIndices<VmOpMap> as OpMapKey<P>]: P };

export function isMachineOp(value: number): value is VmMachineOp {
  return value >= 0 && value <= 15;
}

export function isOp(value: number): value is VmOp {
  return value >= 16;
}
